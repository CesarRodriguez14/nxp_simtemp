From eb87035b9a049e687060c41a4fe8627fe123acc4 Mon Sep 17 00:00:00 2001
From: CesarRodriguez14 <cesrodflo14@hotmail.com>
Date: Sat, 11 Oct 2025 21:13:00 -0500
Subject: [PATCH] nxp-simtemp-driver

---
 drivers/char/Kconfig                              |   1 +
 drivers/char/Makefile                             |   2 +
 drivers/char/nxp_simtemp_driver/Kconfig           |   4 +
 drivers/char/nxp_simtemp_driver/Makefile          |   3 +
 drivers/char/nxp_simtemp_driver/gaussian_random.c |  41 ++
 drivers/char/nxp_simtemp_driver/gaussian_random.h |   8 +
 drivers/char/nxp_simtemp_driver/nxp_simtemp.c     | 441 ++++++++++++++++++++++
 drivers/char/nxp_simtemp_driver/simtemp.h         |  12 +
 8 files changed, 512 insertions(+)
 create mode 100644 drivers/char/nxp_simtemp_driver/Kconfig
 create mode 100644 drivers/char/nxp_simtemp_driver/Makefile
 create mode 100644 drivers/char/nxp_simtemp_driver/gaussian_random.c
 create mode 100644 drivers/char/nxp_simtemp_driver/gaussian_random.h
 create mode 100644 drivers/char/nxp_simtemp_driver/nxp_simtemp.c
 create mode 100644 drivers/char/nxp_simtemp_driver/simtemp.h

diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig
index e225efc..3ef7ff4 100644
--- a/drivers/char/Kconfig
+++ b/drivers/char/Kconfig
@@ -6,6 +6,7 @@
 menu "Character devices"
 
 source "drivers/tty/Kconfig"
+source "drivers/char/nxp_simtemp_driver/Kconfig"
 
 config DEVMEM
 	bool "/dev/mem virtual device support"
diff --git a/drivers/char/Makefile b/drivers/char/Makefile
index 120035c..31cecc6 100644
--- a/drivers/char/Makefile
+++ b/drivers/char/Makefile
@@ -64,3 +64,5 @@ obj-$(CONFIG_ADI)		+= adi.o
 obj-$(CONFIG_MSM_RDBG)		+= rdbg.o
 obj-$(CONFIG_MSM_FASTCVPD)	+= fastcvpd.o
 obj-$(CONFIG_VIRTIO_EAVB)       += virtio_eavb/
+
+obj-${CONFIG_NXP_SIMTEMP_DRIVER} += nxp_simtemp_driver/
diff --git a/drivers/char/nxp_simtemp_driver/Kconfig b/drivers/char/nxp_simtemp_driver/Kconfig
new file mode 100644
index 0000000..dbf3c2e
--- /dev/null
+++ b/drivers/char/nxp_simtemp_driver/Kconfig
@@ -0,0 +1,4 @@
+config NXP_SIMTEMP_DRIVER
+	tristate "NXP-simtemp Driver"
+	help
+		NXP-simtemp Driver
diff --git a/drivers/char/nxp_simtemp_driver/Makefile b/drivers/char/nxp_simtemp_driver/Makefile
new file mode 100644
index 0000000..0681385
--- /dev/null
+++ b/drivers/char/nxp_simtemp_driver/Makefile
@@ -0,0 +1,3 @@
+obj-${CONFIG_NXP_SIMTEMP_DRIVER} := nxp_simtemp_drv.o
+
+nxp_simtemp_drv-objs := nxp_simtemp.o gaussian_random.o
diff --git a/drivers/char/nxp_simtemp_driver/gaussian_random.c b/drivers/char/nxp_simtemp_driver/gaussian_random.c
new file mode 100644
index 0000000..9cb0ea5
--- /dev/null
+++ b/drivers/char/nxp_simtemp_driver/gaussian_random.c
@@ -0,0 +1,41 @@
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/random.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/math64.h>
+#include "gaussian_random.h"
+
+#define CLT_N 12
+
+
+__s32 gaussian_s32_clt(__s32 mean, __s32 stddev)
+{
+	u64 sum = 0;
+	int i = 0;
+	s64 centered;
+	__s32 val = 0;
+	
+	for(i=0; i < CLT_N;i++)
+	{
+		sum += prandom_u32();
+	}
+	
+	
+	centered = (s64)sum - ((s64)CLT_N*(UINT_MAX/2));
+
+	centered = (centered << 16)/((UINT_MAX/2)*CLT_N);
+
+	centered = (centered * stddev) >> 16;
+
+	val = mean + (s32)centered;
+	
+	return val;
+}
+
+EXPORT_SYMBOL(gaussian_s32_clt);
+
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("LASEC TECHNNOLOGIES");
+MODULE_DESCRIPTION("Gaussian RNG Central Limit Theorem");
diff --git a/drivers/char/nxp_simtemp_driver/gaussian_random.h b/drivers/char/nxp_simtemp_driver/gaussian_random.h
new file mode 100644
index 0000000..a026640
--- /dev/null
+++ b/drivers/char/nxp_simtemp_driver/gaussian_random.h
@@ -0,0 +1,8 @@
+#ifndef _GAUSSIAN_RANDOM_H_
+#define _GAUSSIAN_RANDOM_H_
+
+#include <linux/types.h>
+
+__s32 gaussian_s32_clt(__s32 mean, __s32 stddev);
+
+#endif
diff --git a/drivers/char/nxp_simtemp_driver/nxp_simtemp.c b/drivers/char/nxp_simtemp_driver/nxp_simtemp.c
new file mode 100644
index 0000000..0d84fc3
--- /dev/null
+++ b/drivers/char/nxp_simtemp_driver/nxp_simtemp.c
@@ -0,0 +1,441 @@
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+#include <linux/kfifo.h>
+#include <linux/poll.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <linux/err.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include "gaussian_random.h"
+#include "simtemp.h"
+
+//Temperature generation modes
+#define MODE_NRM 0
+#define MODE_NSY 1
+#define MODE_RMP 2
+
+//Ring buffer size
+#define FIFO_SIZE 256
+
+//Temperature simulation
+#define TEMP_MEAN_mC 20000
+#define TEMP_MAX 100000
+#define TEMP_MIN -50000
+
+//Sampling range 
+#define TIME_MIN_us 50 // 20 KHz
+#define TIME_MAX_us 10000000 // 10s
+
+//Events flags
+#define FLAG_NEW_SAMPLE (1<<0)
+#define FLAG_THRESHOLD_CROSSED (1<<1)
+
+//Temperature modes names
+const char * modes[] ={"normal","noisy","ramp"};
+
+//Kernel space variables
+volatile __u32 sampling_us = 100000; //100 ms
+volatile __s32 threshold_mC = 20000; //20 °C
+volatile __u8 mode = MODE_RMP;
+volatile __u8  flags = 0;
+volatile __u32 TEMP_STD_mC = 100; // Temperature standard deviation 0.1 °C
+
+//Statically allocated FIFO and waitqueue
+static DEFINE_KFIFO(CBuffer,struct simtemp_sample,FIFO_SIZE);
+static DECLARE_WAIT_QUEUE_HEAD(wq);
+
+//Define mutexes
+static DEFINE_MUTEX(sampling_us_lock);
+static DEFINE_MUTEX(threshold_mC_lock);
+static DEFINE_MUTEX(mode_lock);
+
+//Define spinlock
+static DEFINE_SPINLOCK(fifo_lock);
+
+//Hrtimer variables
+static struct hrtimer my_timer;
+static ktime_t kt_period;
+
+dev_t dev = 0;
+static struct class *dev_class;
+static struct cdev k_cdev;
+struct kobject *kobj_ref;
+
+static struct simtemp_sample current_sample={.timestamp_ns = 0, .temp_mC = TEMP_MEAN_mC, .flags = 0};
+
+//Prototypes
+
+static int __init nxp_simtemp_init(void);
+static void __exit nxp_simtemp_exit(void);
+
+//Driver functions
+static int nxp_simtemp_open(struct inode *inode,struct file *file);
+static int nxp_simtemp_release(struct inode *inode, struct file *file);
+static ssize_t nxp_simtemp_read(struct file *file, char __user *buf, size_t len, loff_t* off);
+static ssize_t nxp_simtemp_write(struct file *file, const char *buf, size_t len, loff_t* off);
+static unsigned int nxp_simtemp_poll(struct file *file, poll_table *wait);
+
+//sysfs functions
+static ssize_t sampling_us_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
+static ssize_t sampling_us_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);
+static ssize_t threshold_mC_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
+static ssize_t threshold_mC_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);
+static ssize_t mode_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
+static ssize_t mode_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);
+static ssize_t flags_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf);
+static ssize_t flags_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count);
+
+struct kobj_attribute attr_sampling_us = __ATTR(sampling_us, 0660, sampling_us_show,sampling_us_store);
+struct kobj_attribute attr_threshold_mC = __ATTR(threshold_mC, 0660, threshold_mC_show,threshold_mC_store);
+struct kobj_attribute attr_mode= __ATTR(mode, 0660, mode_show,mode_store);
+struct kobj_attribute attr_flags = __ATTR(flags, 0660, flags_show,flags_store);
+
+static struct attribute *sim_temp_attrs[] = {
+	&attr_sampling_us.attr,
+	&attr_threshold_mC.attr,
+	&attr_mode.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = sim_temp_attrs,
+};
+
+//File operation structure
+static struct file_operations fops =
+{
+	.owner		= THIS_MODULE,
+	.read		= nxp_simtemp_read,
+	.write		= nxp_simtemp_write,
+	.poll		= nxp_simtemp_poll,
+	.open		= nxp_simtemp_open,
+	.release	= nxp_simtemp_release,
+};
+
+//Function called when we read the sysfs file
+
+static ssize_t sampling_us_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	pr_info("nxp_simtemp: sampling_us - Read\n");
+	return sprintf(buf,"%u\n",sampling_us);
+}
+
+static ssize_t sampling_us_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret = 0;
+	pr_info("nxp_simtemp: sampling_us - Write\n");
+	mutex_lock(&sampling_us_lock);
+	ret = sscanf(buf,"%u",&sampling_us);
+	mutex_unlock(&sampling_us_lock);
+	if(ret)
+	{
+		if(sampling_us > TIME_MAX_us || sampling_us < TIME_MIN_us)
+		{
+			return -EINVAL;
+		}
+		//Cancel timer
+		hrtimer_cancel(&my_timer);
+		//Update timer
+		kt_period = ktime_set(0,sampling_us*1000);
+		//Restart the timer
+		hrtimer_start(&my_timer,kt_period,HRTIMER_MODE_REL);
+		return count;
+	}
+	else
+	{
+		return -EINVAL;
+	}
+}
+
+static ssize_t threshold_mC_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	pr_info("nxp_simtemp: threshold_mC - Read\n");
+	return sprintf(buf,"%d\n",threshold_mC);
+}
+
+static ssize_t threshold_mC_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret = 0;
+	pr_info("nxp_simtemp: threshold_mC - Write\n");
+	mutex_lock(&threshold_mC_lock);
+	ret = sscanf(buf,"%d",&threshold_mC);
+	mutex_unlock(&threshold_mC_lock);
+	if(ret)
+	{
+		return count;
+	}
+	else
+	{
+		return -EINVAL;
+	}
+}
+
+static ssize_t mode_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	pr_info("nxp_simtemp: mode - Read\n");
+	return sprintf(buf,"%s\n",modes[mode]);
+}
+
+static ssize_t mode_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	char tmp_mode;
+	pr_info("nxp_simtemp: mode - Write\n");
+	sscanf(buf,"%c",&tmp_mode);
+	switch(tmp_mode)
+	{
+		case '0':
+			mutex_lock(&mode_lock);
+			mode = MODE_NRM;
+			TEMP_STD_mC = 100;
+			mutex_unlock(&mode_lock);
+			pr_info("nxp_simtemp: New mode %d : %s",mode,modes[mode]);
+			break;
+		case '1':
+			mutex_lock(&mode_lock);
+			mode = MODE_NSY;
+			TEMP_STD_mC = 2000;
+			mutex_unlock(&mode_lock);
+			pr_info("nxp_simtemp: New mode %d : %s",mode,modes[mode]);
+			break;
+		case '2':
+			mutex_lock(&mode_lock);
+			mode = MODE_RMP;
+			mutex_unlock(&mode_lock);
+			pr_info("nxp_simtemp: New mode %d : %s",mode,modes[mode]);
+			break;
+		default:
+			pr_info("nxp_simtemp: Invalid mode %d",mode);
+			return -EINVAL;
+	}
+	
+	return count;
+}
+
+static ssize_t flags_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	pr_info("nxp_simtemp: flags - Read\n");
+	return sprintf(buf,"%u\n",flags);
+}
+
+static ssize_t flags_store(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int tmp;
+	pr_info("nxp_simtemp: flags - Write\n");
+	sscanf(buf,"%u",&tmp);
+	flags = (__u8)tmp;
+	return count;
+}
+
+static int nxp_simtemp_open(struct inode *inode,struct file *file)
+{
+	pr_info("nxp_simtemp: Device File Opened \n");
+	return 0;
+}
+
+static int nxp_simtemp_release(struct inode *inode, struct file *file)
+{
+	pr_info("nxp_simtemp: Device File Closed \n");
+	return 0;
+}
+
+static ssize_t nxp_simtemp_read(struct file *file, char __user *buf, size_t len, loff_t* off)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&fifo_lock,flags);
+	kfifo_out(&CBuffer,&current_sample,1);
+	spin_unlock_irqrestore(&fifo_lock,flags);
+	
+	copy_to_user((void __user *)buf,&current_sample,sizeof(current_sample));
+	//pr_info("nxp_simtemp: Read function\n");
+	return sizeof(current_sample);
+}
+
+static ssize_t nxp_simtemp_write(struct file *file, const char *buf, size_t len, loff_t* off)
+{
+	pr_info("nxp_simtemp: Write function\n");
+	return len;
+}
+
+static unsigned int nxp_simtemp_poll(struct file *file, poll_table *wait)
+{
+	unsigned int mask = 0;
+	unsigned long flags;
+	
+	poll_wait(file,&wq,wait);
+	//pr_info("nxp_simtemp: Set POLLIN | POLLRDNORM flags\n");
+	
+	spin_lock_irqsave(&fifo_lock,flags);
+	if(!kfifo_is_empty(&CBuffer))
+	{
+		mask |= POLLIN | POLLRDNORM;
+	}
+	spin_unlock_irqrestore(&fifo_lock,flags);
+	
+	return mask;
+}
+
+static enum hrtimer_restart timer_callback(struct hrtimer *timer)
+{
+	struct simtemp_sample old_value;
+	unsigned long flags;
+	
+	if(mode == MODE_NRM || mode == MODE_NSY)
+	{
+		current_sample.temp_mC = gaussian_s32_clt(TEMP_MEAN_mC,TEMP_STD_mC);
+	}
+	else
+	{
+		current_sample.temp_mC = ((current_sample.temp_mC + 1000 - TEMP_MIN) % (TEMP_MAX - TEMP_MIN + 1)) + TEMP_MIN;
+	}
+	current_sample.timestamp_ns = ktime_get_real_ns();
+	current_sample.flags = FLAG_NEW_SAMPLE;
+	if (current_sample.temp_mC > threshold_mC)
+	{
+		current_sample.flags |= FLAG_THRESHOLD_CROSSED; 
+	}
+	
+	spin_lock_irqsave(&fifo_lock,flags);
+	
+	if(kfifo_is_full(&CBuffer))
+	{
+		kfifo_out(&CBuffer,&old_value,1);
+		//pr_info("nxp_simtemp: CBuffer full, oldest value %d dropped\n", old_value);
+	}
+	kfifo_in(&CBuffer,&current_sample,1);
+	//pr_info("nxp_simtemp: %llu | Inserted %d into CBuffer\n",current_sample.timestamp_ns,current_sample.temp_mC);
+	spin_unlock_irqrestore(&fifo_lock,flags);
+	
+	wake_up_interruptible(&wq);
+	
+	//Re-arm the timer
+	hrtimer_forward_now(timer,kt_period);
+	return HRTIMER_RESTART;
+}
+
+static int __init nxp_simtemp_init(void)
+{
+	
+	// Init spinlock
+	spin_lock_init(&fifo_lock);
+	
+	// Set the timer interval
+	kt_period = ktime_set(0,sampling_us*1000); // seconds, nanoseconds
+	
+	// Initialize the hrtimer
+	hrtimer_init(&my_timer,CLOCK_MONOTONIC,HRTIMER_MODE_REL);
+	my_timer.function = timer_callback;
+	
+	//Allocate Major Number
+	if((alloc_chrdev_region(&dev, 0, 1,"simtemp"))<0)
+	{
+		pr_info("nxp_simtemp: Cannot allocate major number\n");
+		return -1;
+	}
+	pr_info("nxp_simtemp: Major = %d Minor = %d \n", MAJOR(dev),MINOR(dev));
+	
+	//Create cdev structure
+	cdev_init(&k_cdev,&fops);
+	
+	//Adding character device to the system
+	if((cdev_add(&k_cdev,dev,1)) < 0)
+	{
+		pr_info("nxp_simtemp: Cannot add the device to the system\n");
+		goto r_class;
+	}
+	
+	//Create struct class
+	if(IS_ERR(dev_class = class_create(THIS_MODULE,"simtemp")))
+	{
+		pr_info("nxp_simtemp: Cannot create the struct class\n");
+		goto r_class;
+	}
+	
+	//Create device
+	if(IS_ERR(device_create(dev_class,NULL,dev,NULL,"simtemp")))
+	{
+		pr_info("nxp_simtemp: Cannot create the Device 1\n");
+		goto r_device;
+		
+	}
+	
+	//Create a directory in /sys/kernel/
+	kobj_ref = kobject_create_and_add("simtemp",kernel_kobj);
+	if(!kobj_ref)
+	{
+		pr_err("Cannot create kobject\n");
+		return -ENOMEM;
+	}
+	
+	//Create sysfs file for k_value
+	if(sysfs_create_group(kobj_ref,&attr_group))
+	{
+		pr_err("Cannot create sysfs group\n");
+		goto r_sysfs;			
+	}
+	
+	//Start the timer
+	hrtimer_start(&my_timer,kt_period,HRTIMER_MODE_REL);
+	
+	pr_info("nxp_simtemp: Device Driver Insert Done\n");
+	return 0;
+
+r_sysfs:
+	sysfs_remove_group(kobj_ref,&attr_group);
+	kobject_put(kobj_ref);
+	return -ENOMEM;
+r_device:
+	class_destroy(dev_class);
+r_class:
+	unregister_chrdev_region(dev,1);
+	cdev_del(&k_cdev);
+	return -1;
+}
+
+static void __exit nxp_simtemp_exit(void)
+{
+	struct simtemp_sample val;
+	int ret = 0;
+	int i = 1;
+	unsigned long flags;
+	
+	//Cancel the timer if it's active
+	ret = hrtimer_cancel(&my_timer);
+	if(ret)
+		pr_info("nxp_simtemp: Timer was still active and canceled\n");
+	
+	//Drain and free FIFO
+	spin_lock_irqsave(&fifo_lock,flags);
+	while(!kfifo_is_empty(&CBuffer))
+	{
+		kfifo_out(&CBuffer,&val,1);
+		pr_info("nxp_simtemp: %d Drained %d\n",i++,val.temp_mC);
+	}
+	spin_unlock_irqrestore(&fifo_lock,flags);
+	
+	sysfs_remove_group(kobj_ref,&attr_group);
+	kobject_put(kobj_ref);
+	device_destroy(dev_class,dev);
+	class_destroy(dev_class);
+	cdev_del(&k_cdev);
+	unregister_chrdev_region(dev,1);
+	pr_info("nxp_simtemp: Device Driver Remove Done\n");
+}
+
+module_init(nxp_simtemp_init);
+module_exit(nxp_simtemp_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("LASEC TECHNOLOGIES SYSTEMS");
+MODULE_DESCRIPTION("Simple Linux device driver (sysfs)");
+MODULE_VERSION("0.1");
diff --git a/drivers/char/nxp_simtemp_driver/simtemp.h b/drivers/char/nxp_simtemp_driver/simtemp.h
new file mode 100644
index 0000000..6e7dfcb
--- /dev/null
+++ b/drivers/char/nxp_simtemp_driver/simtemp.h
@@ -0,0 +1,12 @@
+#ifndef _SIMTEMP_H_
+#define _SIMTEMP_H_
+
+#include <linux/types.h>
+
+struct simtemp_sample {
+	__u64 timestamp_ns; //monotonic timestamp
+	__s32 temp_mC;		//milli-degree Celsius
+	__u32 flags;		//
+}__attribute__((packed));
+
+#endif
-- 
2.7.4

